<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Modern C++ Kafka API: KAFKA_API::clients::KafkaConsumer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Modern C++ Kafka API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>KAFKA_API</b></li><li class="navelem"><b>clients</b></li><li class="navelem"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html">KafkaConsumer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classKAFKA__API_1_1clients_1_1KafkaConsumer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">KAFKA_API::clients::KafkaConsumer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html" title="KafkaConsumer class.">KafkaConsumer</a> class.  
 <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="KafkaConsumer_8h_source.html">KafkaConsumer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for KAFKA_API::clients::KafkaConsumer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classKAFKA__API_1_1clients_1_1KafkaConsumer.png" usemap="#KAFKA_5FAPI::clients::KafkaConsumer_map" alt=""/>
  <map id="KAFKA_5FAPI::clients::KafkaConsumer_map" name="KAFKA_5FAPI::clients::KafkaConsumer_map">
<area href="classKAFKA__API_1_1clients_1_1KafkaClient.html" title="The base class for Kafka clients." alt="KAFKA_API::clients::KafkaClient" shape="rect" coords="0,0,218,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5d56d08cf3e98e7137eafe0c0bde38a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a5d56d08cf3e98e7137eafe0c0bde38a5">KafkaConsumer</a> (const <a class="el" href="classKAFKA__API_1_1Properties.html">Properties</a> &amp;<a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a4f96f756ee68fc0f4c8ee935360a3018">properties</a>, <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#ae7891e26da12ecc9564de418655e576c">EventsPollingOption</a> eventsPollingOption=EventsPollingOption::Auto)</td></tr>
<tr class="memdesc:a5d56d08cf3e98e7137eafe0c0bde38a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html" title="KafkaConsumer class.">KafkaConsumer</a>.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a5d56d08cf3e98e7137eafe0c0bde38a5">More...</a><br /></td></tr>
<tr class="separator:a5d56d08cf3e98e7137eafe0c0bde38a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccf19ee0add3f122383b0f888483f28"><td class="memItemLeft" align="right" valign="top"><a id="a2ccf19ee0add3f122383b0f888483f28"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a2ccf19ee0add3f122383b0f888483f28">~KafkaConsumer</a> () override</td></tr>
<tr class="memdesc:a2ccf19ee0add3f122383b0f888483f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor for <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html" title="KafkaConsumer class.">KafkaConsumer</a>. <br /></td></tr>
<tr class="separator:a2ccf19ee0add3f122383b0f888483f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41c57d5139015e1a7cc990791bdd4c7"><td class="memItemLeft" align="right" valign="top"><a id="ad41c57d5139015e1a7cc990791bdd4c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ad41c57d5139015e1a7cc990791bdd4c7">close</a> ()</td></tr>
<tr class="memdesc:ad41c57d5139015e1a7cc990791bdd4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the consumer, waiting for any needed cleanup. <br /></td></tr>
<tr class="separator:ad41c57d5139015e1a7cc990791bdd4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ca13b700009634dbd8d2a6e54273b0"><td class="memItemLeft" align="right" valign="top"><a id="a41ca13b700009634dbd8d2a6e54273b0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a41ca13b700009634dbd8d2a6e54273b0">getGroupId</a> () const</td></tr>
<tr class="memdesc:a41ca13b700009634dbd8d2a6e54273b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get group ID. <br /></td></tr>
<tr class="separator:a41ca13b700009634dbd8d2a6e54273b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efb218ebb991883ad3edfd237068c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a2efb218ebb991883ad3edfd237068c84">setGroupId</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:a2efb218ebb991883ad3edfd237068c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">To set group ID.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a2efb218ebb991883ad3edfd237068c84">More...</a><br /></td></tr>
<tr class="separator:a2efb218ebb991883ad3edfd237068c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe69aa13f4f37b02e2d771ae33a769a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#abe69aa13f4f37b02e2d771ae33a769a7">subscribe</a> (const Topics &amp;topics, consumer::RebalanceCallback rebalanceCallback=consumer::NullRebalanceCallback, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SUBSCRIBE_TIMEOUT_MS))</td></tr>
<tr class="memdesc:abe69aa13f4f37b02e2d771ae33a769a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to the given list of topics to get dynamically assigned partitions.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#abe69aa13f4f37b02e2d771ae33a769a7">More...</a><br /></td></tr>
<tr class="separator:abe69aa13f4f37b02e2d771ae33a769a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3393b7423462ad20e8e19c86ecbc835"><td class="memItemLeft" align="right" valign="top"><a id="ab3393b7423462ad20e8e19c86ecbc835"></a>
Topics&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ab3393b7423462ad20e8e19c86ecbc835">subscription</a> () const</td></tr>
<tr class="memdesc:ab3393b7423462ad20e8e19c86ecbc835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current subscription. <br /></td></tr>
<tr class="separator:ab3393b7423462ad20e8e19c86ecbc835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8b107a395da5c5dc6ad88dc0513376"><td class="memItemLeft" align="right" valign="top"><a id="a0b8b107a395da5c5dc6ad88dc0513376"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a0b8b107a395da5c5dc6ad88dc0513376">unsubscribe</a> (std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_UNSUBSCRIBE_TIMEOUT_MS))</td></tr>
<tr class="memdesc:a0b8b107a395da5c5dc6ad88dc0513376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe from topics currently subscribed. <br /></td></tr>
<tr class="separator:a0b8b107a395da5c5dc6ad88dc0513376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54956a051ecb5b9ddbe6aa7813d7c94e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a54956a051ecb5b9ddbe6aa7813d7c94e">assign</a> (const TopicPartitions &amp;topicPartitions)</td></tr>
<tr class="memdesc:a54956a051ecb5b9ddbe6aa7813d7c94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually assign a list of partitions to this consumer.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a54956a051ecb5b9ddbe6aa7813d7c94e">More...</a><br /></td></tr>
<tr class="separator:a54956a051ecb5b9ddbe6aa7813d7c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b02c6a98b48dd1b618021a8b097fb0"><td class="memItemLeft" align="right" valign="top"><a id="a93b02c6a98b48dd1b618021a8b097fb0"></a>
TopicPartitions&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a93b02c6a98b48dd1b618021a8b097fb0">assignment</a> () const</td></tr>
<tr class="memdesc:a93b02c6a98b48dd1b618021a8b097fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of partitions currently assigned to this consumer. <br /></td></tr>
<tr class="separator:a93b02c6a98b48dd1b618021a8b097fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9d86457960176e0f939190e5f3d77d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a0b9d86457960176e0f939190e5f3d77d">seek</a> (const TopicPartition &amp;topicPartition, Offset offset, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS))</td></tr>
<tr class="memdesc:a0b9d86457960176e0f939190e5f3d77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides the fetch offsets that the consumer will use on the next poll(timeout).  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a0b9d86457960176e0f939190e5f3d77d">More...</a><br /></td></tr>
<tr class="separator:a0b9d86457960176e0f939190e5f3d77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da9b70046abbc9ce532c49561274f13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a0da9b70046abbc9ce532c49561274f13">seekToBeginning</a> (const TopicPartitions &amp;topicPartitions, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS))</td></tr>
<tr class="memdesc:a0da9b70046abbc9ce532c49561274f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to the first offset for each of the given partitions.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a0da9b70046abbc9ce532c49561274f13">More...</a><br /></td></tr>
<tr class="separator:a0da9b70046abbc9ce532c49561274f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b3ff79f4ccd2cfb4c17a8f4c8d97c0"><td class="memItemLeft" align="right" valign="top"><a id="ab4b3ff79f4ccd2cfb4c17a8f4c8d97c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>seekToBeginning</b> (std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS))</td></tr>
<tr class="separator:ab4b3ff79f4ccd2cfb4c17a8f4c8d97c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0685fc37f59aa2e2513416a881557442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a0685fc37f59aa2e2513416a881557442">seekToEnd</a> (const TopicPartitions &amp;topicPartitions, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS))</td></tr>
<tr class="memdesc:a0685fc37f59aa2e2513416a881557442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to the last offset for each of the given partitions.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a0685fc37f59aa2e2513416a881557442">More...</a><br /></td></tr>
<tr class="separator:a0685fc37f59aa2e2513416a881557442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad029ba6f0e6ac49a0ca43b852f2098d3"><td class="memItemLeft" align="right" valign="top"><a id="ad029ba6f0e6ac49a0ca43b852f2098d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>seekToEnd</b> (std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS))</td></tr>
<tr class="separator:ad029ba6f0e6ac49a0ca43b852f2098d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27d9234efe3bf99b36b62b413fcebb8"><td class="memItemLeft" align="right" valign="top"><a id="ae27d9234efe3bf99b36b62b413fcebb8"></a>
Offset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ae27d9234efe3bf99b36b62b413fcebb8">position</a> (const TopicPartition &amp;topicPartition) const</td></tr>
<tr class="memdesc:ae27d9234efe3bf99b36b62b413fcebb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset of the next record that will be fetched (if a record with that offset exists). <br /></td></tr>
<tr class="separator:ae27d9234efe3bf99b36b62b413fcebb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491d4bf2a07d6c43add3abc4a3de39ad"><td class="memItemLeft" align="right" valign="top">std::map&lt; TopicPartition, Offset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a491d4bf2a07d6c43add3abc4a3de39ad">beginningOffsets</a> (const TopicPartitions &amp;topicPartitions) const</td></tr>
<tr class="memdesc:a491d4bf2a07d6c43add3abc4a3de39ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first offset for the given partitions.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a491d4bf2a07d6c43add3abc4a3de39ad">More...</a><br /></td></tr>
<tr class="separator:a491d4bf2a07d6c43add3abc4a3de39ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b883d6e579965f70fc380b88445946a"><td class="memItemLeft" align="right" valign="top">std::map&lt; TopicPartition, Offset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a6b883d6e579965f70fc380b88445946a">endOffsets</a> (const TopicPartitions &amp;topicPartitions) const</td></tr>
<tr class="memdesc:a6b883d6e579965f70fc380b88445946a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last offset for the given partitions.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a6b883d6e579965f70fc380b88445946a">More...</a><br /></td></tr>
<tr class="separator:a6b883d6e579965f70fc380b88445946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149b50baa7a35bbfddadb1b3c191eaab"><td class="memItemLeft" align="right" valign="top">std::map&lt; TopicPartition, Offset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a149b50baa7a35bbfddadb1b3c191eaab">offsetsForTime</a> (const TopicPartitions &amp;topicPartitions, std::chrono::time_point&lt; std::chrono::system_clock &gt; timepoint, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_QUERY_TIMEOUT_MS)) const</td></tr>
<tr class="memdesc:a149b50baa7a35bbfddadb1b3c191eaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offsets for the given partitions by time-point.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a149b50baa7a35bbfddadb1b3c191eaab">More...</a><br /></td></tr>
<tr class="separator:a149b50baa7a35bbfddadb1b3c191eaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac387b82380b9f822509690f94d1be8db"><td class="memItemLeft" align="right" valign="top"><a id="ac387b82380b9f822509690f94d1be8db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ac387b82380b9f822509690f94d1be8db">commitSync</a> ()</td></tr>
<tr class="memdesc:ac387b82380b9f822509690f94d1be8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offsets returned on the last <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> for all the subscribed list of topics and partitions. <br /></td></tr>
<tr class="separator:ac387b82380b9f822509690f94d1be8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5707a5a2767c741d6c01c180447c24c"><td class="memItemLeft" align="right" valign="top"><a id="ae5707a5a2767c741d6c01c180447c24c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ae5707a5a2767c741d6c01c180447c24c">commitSync</a> (const <a class="el" href="classKAFKA__API_1_1clients_1_1consumer_1_1ConsumerRecord.html">consumer::ConsumerRecord</a> &amp;record)</td></tr>
<tr class="memdesc:ae5707a5a2767c741d6c01c180447c24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the specified offsets for the specified records. <br /></td></tr>
<tr class="separator:ae5707a5a2767c741d6c01c180447c24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae586dddf45cce1008d7b76b9bee22b16"><td class="memItemLeft" align="right" valign="top"><a id="ae586dddf45cce1008d7b76b9bee22b16"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ae586dddf45cce1008d7b76b9bee22b16">commitSync</a> (const TopicPartitionOffsets &amp;topicPartitionOffsets)</td></tr>
<tr class="memdesc:ae586dddf45cce1008d7b76b9bee22b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the specified offsets for the specified list of topics and partitions. <br /></td></tr>
<tr class="separator:ae586dddf45cce1008d7b76b9bee22b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bf154586bf787dc39fa8b6951a4891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ae7bf154586bf787dc39fa8b6951a4891">commitAsync</a> (const consumer::OffsetCommitCallback &amp;offsetCommitCallback=consumer::NullOffsetCommitCallback)</td></tr>
<tr class="memdesc:ae7bf154586bf787dc39fa8b6951a4891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit offsets returned on the last <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> for all the subscribed list of topics and partition.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ae7bf154586bf787dc39fa8b6951a4891">More...</a><br /></td></tr>
<tr class="separator:ae7bf154586bf787dc39fa8b6951a4891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630b093e9fe3a3ca45e5046c7db2c42a"><td class="memItemLeft" align="right" valign="top"><a id="a630b093e9fe3a3ca45e5046c7db2c42a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a630b093e9fe3a3ca45e5046c7db2c42a">commitAsync</a> (const <a class="el" href="classKAFKA__API_1_1clients_1_1consumer_1_1ConsumerRecord.html">consumer::ConsumerRecord</a> &amp;record, const consumer::OffsetCommitCallback &amp;offsetCommitCallback=consumer::NullOffsetCommitCallback)</td></tr>
<tr class="memdesc:a630b093e9fe3a3ca45e5046c7db2c42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the specified offsets for the specified records Note: If a callback is provided, it's guaranteed to be triggered (before closing the consumer). <br /></td></tr>
<tr class="separator:a630b093e9fe3a3ca45e5046c7db2c42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216bb97057c4c5951a1f478331abaf8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a216bb97057c4c5951a1f478331abaf8b">commitAsync</a> (const TopicPartitionOffsets &amp;topicPartitionOffsets, const consumer::OffsetCommitCallback &amp;offsetCommitCallback=consumer::NullOffsetCommitCallback)</td></tr>
<tr class="memdesc:a216bb97057c4c5951a1f478331abaf8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the specified offsets for the specified list of topics and partitions to Kafka.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a216bb97057c4c5951a1f478331abaf8b">More...</a><br /></td></tr>
<tr class="separator:a216bb97057c4c5951a1f478331abaf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05faf6e0c4eedac696c7a40536f36bc8"><td class="memItemLeft" align="right" valign="top">Offset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a05faf6e0c4eedac696c7a40536f36bc8">committed</a> (const TopicPartition &amp;topicPartition)</td></tr>
<tr class="memdesc:a05faf6e0c4eedac696c7a40536f36bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last committed offset for the given partition (whether the commit happened by this process or another).This offset will be used as the position for the consumer in the event of a failure.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a05faf6e0c4eedac696c7a40536f36bc8">More...</a><br /></td></tr>
<tr class="separator:a05faf6e0c4eedac696c7a40536f36bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d7cf9d7a9f72912c467604ffcfcd6e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classKAFKA__API_1_1clients_1_1consumer_1_1ConsumerRecord.html">consumer::ConsumerRecord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e">poll</a> (std::chrono::milliseconds timeout)</td></tr>
<tr class="memdesc:a00d7cf9d7a9f72912c467604ffcfcd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e">More...</a><br /></td></tr>
<tr class="separator:a00d7cf9d7a9f72912c467604ffcfcd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac9b50e10e3b0a14e30d3fff6999517"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a2ac9b50e10e3b0a14e30d3fff6999517">poll</a> (std::chrono::milliseconds timeout, std::vector&lt; <a class="el" href="classKAFKA__API_1_1clients_1_1consumer_1_1ConsumerRecord.html">consumer::ConsumerRecord</a> &gt; &amp;output)</td></tr>
<tr class="memdesc:a2ac9b50e10e3b0a14e30d3fff6999517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a2ac9b50e10e3b0a14e30d3fff6999517">More...</a><br /></td></tr>
<tr class="separator:a2ac9b50e10e3b0a14e30d3fff6999517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15da965785b576d657ed7528108f9569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a15da965785b576d657ed7528108f9569">pause</a> (const TopicPartitions &amp;topicPartitions)</td></tr>
<tr class="memdesc:a15da965785b576d657ed7528108f9569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend fetching from the requested partitions.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a15da965785b576d657ed7528108f9569">More...</a><br /></td></tr>
<tr class="separator:a15da965785b576d657ed7528108f9569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b564a1e1f49a8df531d102d788a4552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a1b564a1e1f49a8df531d102d788a4552">pause</a> ()</td></tr>
<tr class="memdesc:a1b564a1e1f49a8df531d102d788a4552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend fetching from all assigned partitions.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a1b564a1e1f49a8df531d102d788a4552">More...</a><br /></td></tr>
<tr class="separator:a1b564a1e1f49a8df531d102d788a4552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78677d2a718378a1dce3311dfdaeac01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a78677d2a718378a1dce3311dfdaeac01">resume</a> (const TopicPartitions &amp;topicPartitions)</td></tr>
<tr class="memdesc:a78677d2a718378a1dce3311dfdaeac01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume specified partitions which have been paused with <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a1b564a1e1f49a8df531d102d788a4552" title="Suspend fetching from all assigned partitions.">pause()</a>.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a78677d2a718378a1dce3311dfdaeac01">More...</a><br /></td></tr>
<tr class="separator:a78677d2a718378a1dce3311dfdaeac01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f1201c8541c7732e839715ba548180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#af7f1201c8541c7732e839715ba548180">resume</a> ()</td></tr>
<tr class="memdesc:af7f1201c8541c7732e839715ba548180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume all partitions which have been paused with <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a1b564a1e1f49a8df531d102d788a4552" title="Suspend fetching from all assigned partitions.">pause()</a>.  <a href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#af7f1201c8541c7732e839715ba548180">More...</a><br /></td></tr>
<tr class="separator:af7f1201c8541c7732e839715ba548180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad415ffa88343298fc270ac80b7d357e2"><td class="memItemLeft" align="right" valign="top"><a id="ad415ffa88343298fc270ac80b7d357e2"></a>
<a class="el" href="classKAFKA__API_1_1clients_1_1consumer_1_1ConsumerGroupMetadata.html">consumer::ConsumerGroupMetadata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ad415ffa88343298fc270ac80b7d357e2">groupMetadata</a> ()</td></tr>
<tr class="memdesc:ad415ffa88343298fc270ac80b7d357e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current group metadata associated with this consumer. <br /></td></tr>
<tr class="separator:ad415ffa88343298fc270ac80b7d357e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html">KAFKA_API::clients::KafkaClient</a></td></tr>
<tr class="memitem:a1f6b90a929cd10cea5ca87973bcf242b inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a1f6b90a929cd10cea5ca87973bcf242b"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a1f6b90a929cd10cea5ca87973bcf242b">clientId</a> () const</td></tr>
<tr class="memdesc:a1f6b90a929cd10cea5ca87973bcf242b inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the client id. <br /></td></tr>
<tr class="separator:a1f6b90a929cd10cea5ca87973bcf242b inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b5c908c067a69ebad5d00c1266f728 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#aa7b5c908c067a69ebad5d00c1266f728">name</a> () const</td></tr>
<tr class="memdesc:aa7b5c908c067a69ebad5d00c1266f728 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the client name (i.e.  <a href="classKAFKA__API_1_1clients_1_1KafkaClient.html#aa7b5c908c067a69ebad5d00c1266f728">More...</a><br /></td></tr>
<tr class="separator:aa7b5c908c067a69ebad5d00c1266f728 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb78a1dd5ef8d069e5342e5f1063e6 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="adecb78a1dd5ef8d069e5342e5f1063e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#adecb78a1dd5ef8d069e5342e5f1063e6">setLogger</a> (Logger logger)</td></tr>
<tr class="memdesc:adecb78a1dd5ef8d069e5342e5f1063e6 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the log callback for the kafka client (it's a per-client setting). <br /></td></tr>
<tr class="separator:adecb78a1dd5ef8d069e5342e5f1063e6 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4954d6ff2b27d9085b75ced85be1a1b4 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a4954d6ff2b27d9085b75ced85be1a1b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a4954d6ff2b27d9085b75ced85be1a1b4">setLogLevel</a> (int level)</td></tr>
<tr class="memdesc:a4954d6ff2b27d9085b75ced85be1a1b4 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set log level for the kafka client (the default value: 5). <br /></td></tr>
<tr class="separator:a4954d6ff2b27d9085b75ced85be1a1b4 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ac8feee2c9155821b09b01f8c3f003 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a05ac8feee2c9155821b09b01f8c3f003">setStatsCallback</a> (<a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a75ea5fadbf115f897396fa41a6101645">StatsCallback</a> cb)</td></tr>
<tr class="memdesc:a05ac8feee2c9155821b09b01f8c3f003 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback to receive the periodic statistics info.  <a href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a05ac8feee2c9155821b09b01f8c3f003">More...</a><br /></td></tr>
<tr class="separator:a05ac8feee2c9155821b09b01f8c3f003 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9903a3c39dcddd713a86279724a9fa70 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a9903a3c39dcddd713a86279724a9fa70"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a9903a3c39dcddd713a86279724a9fa70">setErrorCallback</a> (<a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#afab1aa1d16f1f2cf47e5e6bdf9feeed3">ErrorCallback</a> cb)</td></tr>
<tr class="memdesc:a9903a3c39dcddd713a86279724a9fa70 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback for error notification. <br /></td></tr>
<tr class="separator:a9903a3c39dcddd713a86279724a9fa70 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f96f756ee68fc0f4c8ee935360a3018 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a4f96f756ee68fc0f4c8ee935360a3018"></a>
const <a class="el" href="classKAFKA__API_1_1Properties.html">Properties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a4f96f756ee68fc0f4c8ee935360a3018">properties</a> () const</td></tr>
<tr class="memdesc:a4f96f756ee68fc0f4c8ee935360a3018 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the properties which took effect. <br /></td></tr>
<tr class="separator:a4f96f756ee68fc0f4c8ee935360a3018 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e70f6afaa93f7dc6b930b16d05ad35 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a73e70f6afaa93f7dc6b930b16d05ad35"></a>
Optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a73e70f6afaa93f7dc6b930b16d05ad35">getProperty</a> (const std::string &amp;<a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#aa7b5c908c067a69ebad5d00c1266f728">name</a>) const</td></tr>
<tr class="memdesc:a73e70f6afaa93f7dc6b930b16d05ad35 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the effected property (including the property internally set by librdkafka). <br /></td></tr>
<tr class="separator:a73e70f6afaa93f7dc6b930b16d05ad35 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2935c5b2fb8b8467fd89f60183d1734 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="ac2935c5b2fb8b8467fd89f60183d1734"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#ac2935c5b2fb8b8467fd89f60183d1734">pollEvents</a> (std::chrono::milliseconds timeout)</td></tr>
<tr class="memdesc:ac2935c5b2fb8b8467fd89f60183d1734 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the OffsetCommit callbacks (if any) Note: The Kafka client should be constructed with option <code>EventsPollingOption::Manual</code>. <br /></td></tr>
<tr class="separator:ac2935c5b2fb8b8467fd89f60183d1734 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012ecf14a8328f7349f7fc886ba8d090 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top">Optional&lt; <a class="el" href="structKAFKA__API_1_1BrokerMetadata.html">BrokerMetadata</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a012ecf14a8328f7349f7fc886ba8d090">fetchBrokerMetadata</a> (const std::string &amp;topic, std::chrono::milliseconds timeout=std::chrono::milliseconds(DEFAULT_METADATA_TIMEOUT_MS), bool disableErrorLogging=false)</td></tr>
<tr class="memdesc:a012ecf14a8328f7349f7fc886ba8d090 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch matadata from a available broker.  <a href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a012ecf14a8328f7349f7fc886ba8d090">More...</a><br /></td></tr>
<tr class="separator:a012ecf14a8328f7349f7fc886ba8d090 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4189bb09eaa1ae2df826e174ef0ee923 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memTemplParams" colspan="2"><a id="a4189bb09eaa1ae2df826e174ef0ee923"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a4189bb09eaa1ae2df826e174ef0ee923 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>doLog</b> (int level, const char *filename, int lineno, const char *format, Args... args) const</td></tr>
<tr class="separator:a4189bb09eaa1ae2df826e174ef0ee923 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e7e67da7bffff7e4a1e3c38ae05b81 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a50e7e67da7bffff7e4a1e3c38ae05b81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>doLog</b> (int level, const char *filename, int lineno, const char *msg) const</td></tr>
<tr class="separator:a50e7e67da7bffff7e4a1e3c38ae05b81 inherit pub_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a024a9eefd2c2f6461933cfc4628fdda4"><td class="memItemLeft" align="right" valign="top"><a id="a024a9eefd2c2f6461933cfc4628fdda4"></a>
static const constexpr char *&#160;</td><td class="memItemRight" valign="bottom"><b>DEFAULT_MAX_POLL_RECORDS_VALUE</b> = &quot;500&quot;</td></tr>
<tr class="separator:a024a9eefd2c2f6461933cfc4628fdda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classKAFKA__API_1_1clients_1_1KafkaClient')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html">KAFKA_API::clients::KafkaClient</a></td></tr>
<tr class="memitem:ae7891e26da12ecc9564de418655e576c inherit pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="ae7891e26da12ecc9564de418655e576c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#ae7891e26da12ecc9564de418655e576c">EventsPollingOption</a> { <b>Manual</b>, 
<b>Auto</b>
 }</td></tr>
<tr class="memdesc:ae7891e26da12ecc9564de418655e576c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The option shows whether user wants to call <code><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#ac2935c5b2fb8b8467fd89f60183d1734" title="Call the OffsetCommit callbacks (if any) Note: The Kafka client should be constructed with option Eve...">pollEvents()</a></code> manually to trigger internal callbacks. <br /></td></tr>
<tr class="separator:ae7891e26da12ecc9564de418655e576c inherit pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7280a666b8700348ad8ab396918a162a inherit pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a7280a666b8700348ad8ab396918a162a"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>DEFAULT_METADATA_TIMEOUT_MS</b> = 10000
 }</td></tr>
<tr class="separator:a7280a666b8700348ad8ab396918a162a inherit pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ea5fadbf115f897396fa41a6101645 inherit pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a75ea5fadbf115f897396fa41a6101645"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a75ea5fadbf115f897396fa41a6101645">StatsCallback</a> = std::function&lt; void(const std::string &amp;)&gt;</td></tr>
<tr class="memdesc:a75ea5fadbf115f897396fa41a6101645 inherit pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for statistics info dumping. <br /></td></tr>
<tr class="separator:a75ea5fadbf115f897396fa41a6101645 inherit pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab1aa1d16f1f2cf47e5e6bdf9feeed3 inherit pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="afab1aa1d16f1f2cf47e5e6bdf9feeed3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#afab1aa1d16f1f2cf47e5e6bdf9feeed3">ErrorCallback</a> = std::function&lt; void(const <a class="el" href="classKAFKA__API_1_1Error.html">Error</a> &amp;)&gt;</td></tr>
<tr class="memdesc:afab1aa1d16f1f2cf47e5e6bdf9feeed3 inherit pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for error notification. <br /></td></tr>
<tr class="separator:afab1aa1d16f1f2cf47e5e6bdf9feeed3 inherit pub_types_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classKAFKA__API_1_1clients_1_1KafkaClient')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html">KAFKA_API::clients::KafkaClient</a></td></tr>
<tr class="memitem:a2660c0e701c823e004fdb59c4aa6713a inherit pub_static_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a2660c0e701c823e004fdb59c4aa6713a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#a2660c0e701c823e004fdb59c4aa6713a">setGlobalLogger</a> (Logger logger=NullLogger)</td></tr>
<tr class="memdesc:a2660c0e701c823e004fdb59c4aa6713a inherit pub_static_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a log callback for kafka clients, which do not have a client specific logging callback configured (see <code>setLogger</code>). <br /></td></tr>
<tr class="separator:a2660c0e701c823e004fdb59c4aa6713a inherit pub_static_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ab22735916ccf5e2cc941ed7e05bad inherit pub_static_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memTemplParams" colspan="2"><a id="a21ab22735916ccf5e2cc941ed7e05bad"></a>
template&lt;class ... Args&gt; </td></tr>
<tr class="memitem:a21ab22735916ccf5e2cc941ed7e05bad inherit pub_static_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>doGlobalLog</b> (int level, const char *filename, int lineno, const char *format, Args... args)</td></tr>
<tr class="separator:a21ab22735916ccf5e2cc941ed7e05bad inherit pub_static_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36da7043d8cf979dbd11477c4c2a54eb inherit pub_static_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memItemLeft" align="right" valign="top"><a id="a36da7043d8cf979dbd11477c4c2a54eb"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>doGlobalLog</b> (int level, const char *filename, int lineno, const char *msg)</td></tr>
<tr class="separator:a36da7043d8cf979dbd11477c4c2a54eb inherit pub_static_methods_classKAFKA__API_1_1clients_1_1KafkaClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html" title="KafkaConsumer class.">KafkaConsumer</a> class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5d56d08cf3e98e7137eafe0c0bde38a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d56d08cf3e98e7137eafe0c0bde38a5">&#9670;&nbsp;</a></span>KafkaConsumer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KAFKA_API::clients::KafkaConsumer::KafkaConsumer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classKAFKA__API_1_1Properties.html">Properties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#ae7891e26da12ecc9564de418655e576c">EventsPollingOption</a>&#160;</td>
          <td class="paramname"><em>eventsPollingOption</em> = <code>EventsPollingOption::Auto</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor for <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html" title="KafkaConsumer class.">KafkaConsumer</a>. </p>
<p>Options:</p><ul>
<li>EventsPollingOption::Auto (default) : An internal thread would be started for OffsetCommit callbacks handling.</li>
<li>EventsPollingOption::Maunal : User have to call the member function <code><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaClient.html#ac2935c5b2fb8b8467fd89f60183d1734" title="Call the OffsetCommit callbacks (if any) Note: The Kafka client should be constructed with option Eve...">pollEvents()</a></code> to trigger OffsetCommit callbacks.</li>
</ul>
<p>Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__INVALID_ARG : Invalid BOOTSTRAP_SERVERS property</li>
<li>RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE: Fail to create internal threads </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a54956a051ecb5b9ddbe6aa7813d7c94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54956a051ecb5b9ddbe6aa7813d7c94e">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::assign </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>topicPartitions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually assign a list of partitions to this consumer. </p>
<p>An exception would be thrown if subscribe is called previously (without a subsequent call to <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a0b8b107a395da5c5dc6ad88dc0513376" title="Unsubscribe from topics currently subscribed.">unsubscribe()</a>) </p>

</div>
</div>
<a id="a491d4bf2a07d6c43add3abc4a3de39ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491d4bf2a07d6c43add3abc4a3de39ad">&#9670;&nbsp;</a></span>beginningOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;TopicPartition, Offset&gt; KAFKA_API::clients::KafkaConsumer::beginningOffsets </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>topicPartitions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first offset for the given partitions. </p>
<p>This method does not change the current consumer position of the partitions. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__FAIL: Generic failure </li>
</ul>

</div>
</div>
<a id="ae7bf154586bf787dc39fa8b6951a4891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bf154586bf787dc39fa8b6951a4891">&#9670;&nbsp;</a></span>commitAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::commitAsync </td>
          <td>(</td>
          <td class="paramtype">const consumer::OffsetCommitCallback &amp;&#160;</td>
          <td class="paramname"><em>offsetCommitCallback</em> = <code>consumer::NullOffsetCommitCallback</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit offsets returned on the last <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> for all the subscribed list of topics and partition. </p>
<p>Note: If a callback is provided, it's guaranteed to be triggered (before closing the consumer). </p>

</div>
</div>
<a id="a216bb97057c4c5951a1f478331abaf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216bb97057c4c5951a1f478331abaf8b">&#9670;&nbsp;</a></span>commitAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::commitAsync </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitionOffsets &amp;&#160;</td>
          <td class="paramname"><em>topicPartitionOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const consumer::OffsetCommitCallback &amp;&#160;</td>
          <td class="paramname"><em>offsetCommitCallback</em> = <code>consumer::NullOffsetCommitCallback</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit the specified offsets for the specified list of topics and partitions to Kafka. </p>
<p>Note: If a callback is provided, it's guaranteed to be triggered (before closing the consumer). </p>

</div>
</div>
<a id="a05faf6e0c4eedac696c7a40536f36bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05faf6e0c4eedac696c7a40536f36bc8">&#9670;&nbsp;</a></span>committed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Offset KAFKA_API::clients::KafkaConsumer::committed </td>
          <td>(</td>
          <td class="paramtype">const TopicPartition &amp;&#160;</td>
          <td class="paramname"><em>topicPartition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last committed offset for the given partition (whether the commit happened by this process or another).This offset will be used as the position for the consumer in the event of a failure. </p>
<p>This call will block to do a remote call to get the latest committed offsets from the server. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__INVALID_ARG: Invalid partition </li>
</ul>

</div>
</div>
<a id="a6b883d6e579965f70fc380b88445946a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b883d6e579965f70fc380b88445946a">&#9670;&nbsp;</a></span>endOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;TopicPartition, Offset&gt; KAFKA_API::clients::KafkaConsumer::endOffsets </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>topicPartitions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last offset for the given partitions. </p>
<p>The last offset of a partition is the offset of the upcoming message, i.e. the offset of the last available message + 1. This method does not change the current consumer position of the partitions. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__FAIL: Generic failure </li>
</ul>

</div>
</div>
<a id="a149b50baa7a35bbfddadb1b3c191eaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149b50baa7a35bbfddadb1b3c191eaab">&#9670;&nbsp;</a></span>offsetsForTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; TopicPartition, Offset &gt; KAFKA_API::clients::KafkaConsumer::offsetsForTime </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>topicPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td>
          <td class="paramname"><em>timepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(DEFAULT_QUERY_TIMEOUT_MS)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offsets for the given partitions by time-point. </p>
<p>Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__TIMED_OUT: Not all offsets could be fetched in time.</li>
<li>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION: All partitions are unknown.</li>
<li>RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE: Unable to query leaders from the given partitions. </li>
</ul>

</div>
</div>
<a id="a1b564a1e1f49a8df531d102d788a4552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b564a1e1f49a8df531d102d788a4552">&#9670;&nbsp;</a></span>pause() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspend fetching from all assigned partitions. </p>
<p>Future calls to <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> will not return any records until they have been resumed using <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#af7f1201c8541c7732e839715ba548180" title="Resume all partitions which have been paused with pause().">resume()</a>. Note: This method does not affect partition subscription/assignment. </p>

</div>
</div>
<a id="a15da965785b576d657ed7528108f9569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15da965785b576d657ed7528108f9569">&#9670;&nbsp;</a></span>pause() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::pause </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>topicPartitions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspend fetching from the requested partitions. </p>
<p>Future calls to <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> will not return any records from these partitions until they have been resumed using <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#af7f1201c8541c7732e839715ba548180" title="Resume all partitions which have been paused with pause().">resume()</a>. Note: 1) After pausing, the application still need to call <code><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a></code> at regular intervals. 2) This method does not affect partition subscription/assignment (i.e, pause fetching from partitions would not trigger a rebalance, since the consumer is still alive). 3) If none of the provided partitions is assigned to this consumer, an exception would be thrown. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with error:</p><ul>
<li>RD_KAFKA_RESP_ERR__INVALID_ARG: Invalid arguments </li>
</ul>

</div>
</div>
<a id="a00d7cf9d7a9f72912c467604ffcfcd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d7cf9d7a9f72912c467604ffcfcd6e">&#9670;&nbsp;</a></span>poll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classKAFKA__API_1_1clients_1_1consumer_1_1ConsumerRecord.html">consumer::ConsumerRecord</a> &gt; KAFKA_API::clients::KafkaConsumer::poll </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch data for the topics or partitions specified using one of the subscribe/assign APIs. </p>
<p>Returns the polled records. Note: 1) The result could be fetched through ConsumerRecord (with member function <code>error</code>). 2) Make sure the <code>ConsumerRecord</code> be destructed before the <code><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ad41c57d5139015e1a7cc990791bdd4c7" title="Close the consumer, waiting for any needed cleanup.">KafkaConsumer.close()</a></code>. </p>

</div>
</div>
<a id="a2ac9b50e10e3b0a14e30d3fff6999517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac9b50e10e3b0a14e30d3fff6999517">&#9670;&nbsp;</a></span>poll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t KAFKA_API::clients::KafkaConsumer::poll </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classKAFKA__API_1_1clients_1_1consumer_1_1ConsumerRecord.html">consumer::ConsumerRecord</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch data for the topics or partitions specified using one of the subscribe/assign APIs. </p>
<p>Returns the number of polled records (which have been saved into parameter <code>output</code>). Note: 1) The result could be fetched through ConsumerRecord (with member function <code>error</code>). 2) Make sure the <code>ConsumerRecord</code> be destructed before the <code><a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#ad41c57d5139015e1a7cc990791bdd4c7" title="Close the consumer, waiting for any needed cleanup.">KafkaConsumer.close()</a></code>. </p>

</div>
</div>
<a id="af7f1201c8541c7732e839715ba548180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f1201c8541c7732e839715ba548180">&#9670;&nbsp;</a></span>resume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume all partitions which have been paused with <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a1b564a1e1f49a8df531d102d788a4552" title="Suspend fetching from all assigned partitions.">pause()</a>. </p>
<p>New calls to <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> will return records from these partitions if there are any to be fetched. </p>

</div>
</div>
<a id="a78677d2a718378a1dce3311dfdaeac01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78677d2a718378a1dce3311dfdaeac01">&#9670;&nbsp;</a></span>resume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::resume </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>topicPartitions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resume specified partitions which have been paused with <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a1b564a1e1f49a8df531d102d788a4552" title="Suspend fetching from all assigned partitions.">pause()</a>. </p>
<p>New calls to <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a> will return records from these partitions if there are any to be fetched. Note: If the partitions were not previously paused, this method is a no-op. </p>

</div>
</div>
<a id="a0b9d86457960176e0f939190e5f3d77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9d86457960176e0f939190e5f3d77d">&#9670;&nbsp;</a></span>seek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::seek </td>
          <td>(</td>
          <td class="paramtype">const TopicPartition &amp;&#160;</td>
          <td class="paramname"><em>topicPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Offset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides the fetch offsets that the consumer will use on the next poll(timeout). </p>
<p>If this API is invoked for the same partition more than once, the latest offset will be used on the next <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a00d7cf9d7a9f72912c467604ffcfcd6e" title="Fetch data for the topics or partitions specified using one of the subscribe/assign APIs.">poll()</a>. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__TIMED_OUT: Operation timed out</li>
<li>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION: Invalid partition</li>
<li>RD_KAFKA_RESP_ERR__STATE: Invalid broker state </li>
</ul>

</div>
</div>
<a id="a0da9b70046abbc9ce532c49561274f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da9b70046abbc9ce532c49561274f13">&#9670;&nbsp;</a></span>seekToBeginning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::seekToBeginning </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>topicPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek to the first offset for each of the given partitions. </p>
<p>This function evaluates lazily, seeking to the first offset in all partitions only when poll(long) or position(TopicPartition) are called. If no partitions are provided, seek to the first offset for all of the currently assigned partitions. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__TIMED_OUT: Operation timed out</li>
<li>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION: Invalid partition</li>
<li>RD_KAFKA_RESP_ERR__STATE: Invalid broker state </li>
</ul>

</div>
</div>
<a id="a0685fc37f59aa2e2513416a881557442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0685fc37f59aa2e2513416a881557442">&#9670;&nbsp;</a></span>seekToEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::seekToEnd </td>
          <td>(</td>
          <td class="paramtype">const TopicPartitions &amp;&#160;</td>
          <td class="paramname"><em>topicPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(DEFAULT_SEEK_TIMEOUT_MS)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seek to the last offset for each of the given partitions. </p>
<p>This function evaluates lazily, seeking to the final offset in all partitions only when poll(long) or position(TopicPartition) are called. If no partitions are provided, seek to the first offset for all of the currently assigned partitions. Throws <a class="el" href="classKAFKA__API_1_1KafkaException.html" title="Specific exception for Kafka clients.">KafkaException</a> with errors:</p><ul>
<li>RD_KAFKA_RESP_ERR__TIMED_OUT: Operation timed out</li>
<li>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION: Invalid partition</li>
<li>RD_KAFKA_RESP_ERR__STATE: Invalid broker state </li>
</ul>

</div>
</div>
<a id="a2efb218ebb991883ad3edfd237068c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efb218ebb991883ad3edfd237068c84">&#9670;&nbsp;</a></span>setGroupId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::setGroupId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To set group ID. </p>
<p>The group ID is mandatory for a Consumer. </p>

</div>
</div>
<a id="abe69aa13f4f37b02e2d771ae33a769a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe69aa13f4f37b02e2d771ae33a769a7">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KAFKA_API::clients::KafkaConsumer::subscribe </td>
          <td>(</td>
          <td class="paramtype">const Topics &amp;&#160;</td>
          <td class="paramname"><em>topics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">consumer::RebalanceCallback&#160;</td>
          <td class="paramname"><em>rebalanceCallback</em> = <code>consumer::NullRebalanceCallback</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(DEFAULT_SUBSCRIBE_TIMEOUT_MS)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe to the given list of topics to get dynamically assigned partitions. </p>
<p>An exception would be thrown if assign is called previously (without a subsequent call to <a class="el" href="classKAFKA__API_1_1clients_1_1KafkaConsumer.html#a0b8b107a395da5c5dc6ad88dc0513376" title="Unsubscribe from topics currently subscribed.">unsubscribe()</a>) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/modern-cpp-kafka/modern-cpp-kafka/include/kafka/<a class="el" href="KafkaConsumer_8h_source.html">KafkaConsumer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
